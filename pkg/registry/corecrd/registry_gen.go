// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by:
//     kinds/gen.go
// Using jennies:
//     CRDKindRegistryJenny
//
// Run 'make gen-cue' from repository root to regenerate.

package corecrd

import (
	"encoding/json"
	"fmt"

	dashboard "github.com/grafana/grafana/pkg/kinds/dashboard/crd"
	librarypanel "github.com/grafana/grafana/pkg/kinds/librarypanel/crd"
	playlist "github.com/grafana/grafana/pkg/kinds/playlist/crd"
	preferences "github.com/grafana/grafana/pkg/kinds/preferences/crd"
	publicdashboard "github.com/grafana/grafana/pkg/kinds/publicdashboard/crd"
	serviceaccount "github.com/grafana/grafana/pkg/kinds/serviceaccount/crd"
	team "github.com/grafana/grafana/pkg/kinds/team/crd"
	"github.com/grafana/grafana/pkg/registry/corekind"
	"github.com/grafana/kindsys/k8ssys"
	"gopkg.in/yaml.v3"
)

// Registry is a list of all of Grafana's core structured kinds, wrapped in a
// standard [k8ssys.CRD] interface that makes them usable for interactions
// with certain Kubernetes controller and apimachinery libraries.
//
// There are two access methods: individually via literal named methods, or as
// a slice returned from All() method.
//
// Prefer the individual named methods for use cases where the particular kind(s)
// that are needed are known to the caller. Prefer All() when performing operations
// generically across all kinds.
type Registry struct {
	all [7]k8ssys.Kind
}

// Dashboard returns the [k8ssys.Kind] instance for the Dashboard kind.
func (r *Registry) Dashboard() k8ssys.Kind {
	return r.all[0]
}

// LibraryPanel returns the [k8ssys.Kind] instance for the LibraryPanel kind.
func (r *Registry) LibraryPanel() k8ssys.Kind {
	return r.all[1]
}

// Playlist returns the [k8ssys.Kind] instance for the Playlist kind.
func (r *Registry) Playlist() k8ssys.Kind {
	return r.all[2]
}

// Preferences returns the [k8ssys.Kind] instance for the Preferences kind.
func (r *Registry) Preferences() k8ssys.Kind {
	return r.all[3]
}

// PublicDashboard returns the [k8ssys.Kind] instance for the PublicDashboard kind.
func (r *Registry) PublicDashboard() k8ssys.Kind {
	return r.all[4]
}

// ServiceAccount returns the [k8ssys.Kind] instance for the ServiceAccount kind.
func (r *Registry) ServiceAccount() k8ssys.Kind {
	return r.all[5]
}

// Team returns the [k8ssys.Kind] instance for the Team kind.
func (r *Registry) Team() k8ssys.Kind {
	return r.all[6]
}

func doNewRegistry(breg *corekind.Base) *Registry {
	var err error
	var b []byte
	var kk k8ssys.Kind
	reg := &Registry{}

	kk = k8ssys.Kind{
		GrafanaKind: breg.Dashboard(),
		Object:      &dashboard.Dashboard{},
		ObjectList:  &dashboard.DashboardList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map0 := make(map[string]any)
	err = yaml.Unmarshal(dashboard.CRDYaml, map0)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Dashboard failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map0)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Dashboard: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Dashboard: %s", err))
	}
	reg.all[0] = kk

	kk = k8ssys.Kind{
		GrafanaKind: breg.LibraryPanel(),
		Object:      &librarypanel.LibraryPanel{},
		ObjectList:  &librarypanel.LibraryPanelList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map1 := make(map[string]any)
	err = yaml.Unmarshal(librarypanel.CRDYaml, map1)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for LibraryPanel failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map1)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for LibraryPanel: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for LibraryPanel: %s", err))
	}
	reg.all[1] = kk

	kk = k8ssys.Kind{
		GrafanaKind: breg.Playlist(),
		Object:      &playlist.Playlist{},
		ObjectList:  &playlist.PlaylistList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map2 := make(map[string]any)
	err = yaml.Unmarshal(playlist.CRDYaml, map2)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Playlist failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map2)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Playlist: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Playlist: %s", err))
	}
	reg.all[2] = kk

	kk = k8ssys.Kind{
		GrafanaKind: breg.Preferences(),
		Object:      &preferences.Preferences{},
		ObjectList:  &preferences.PreferencesList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map3 := make(map[string]any)
	err = yaml.Unmarshal(preferences.CRDYaml, map3)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Preferences failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map3)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Preferences: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Preferences: %s", err))
	}
	reg.all[3] = kk

	kk = k8ssys.Kind{
		GrafanaKind: breg.PublicDashboard(),
		Object:      &publicdashboard.PublicDashboard{},
		ObjectList:  &publicdashboard.PublicDashboardList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map4 := make(map[string]any)
	err = yaml.Unmarshal(publicdashboard.CRDYaml, map4)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for PublicDashboard failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map4)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for PublicDashboard: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for PublicDashboard: %s", err))
	}
	reg.all[4] = kk

	kk = k8ssys.Kind{
		GrafanaKind: breg.ServiceAccount(),
		Object:      &serviceaccount.ServiceAccount{},
		ObjectList:  &serviceaccount.ServiceAccountList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map5 := make(map[string]any)
	err = yaml.Unmarshal(serviceaccount.CRDYaml, map5)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for ServiceAccount failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map5)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for ServiceAccount: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for ServiceAccount: %s", err))
	}
	reg.all[5] = kk

	kk = k8ssys.Kind{
		GrafanaKind: breg.Team(),
		Object:      &team.Team{},
		ObjectList:  &team.TeamList{},
	}
	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map6 := make(map[string]any)
	err = yaml.Unmarshal(team.CRDYaml, map6)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Team failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map6)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Team: %s", err))
	}
	err = json.Unmarshal(b, &kk.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Team: %s", err))
	}
	reg.all[6] = kk

	return reg
}
